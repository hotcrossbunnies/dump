local ServerHop = true
if ServerHop then
    wait(10)
end
local Players = game:GetService("Players") -- p
local LocalPlayer = Players.LocalPlayer -- lp

local function predict(target)
    local v = target.Velocity
    local p = Vector3.new(v.X, v.Y / 5, v.Z - .2) / (.4 * ((LocalPlayer:GetNetworkPing() * 1000) / 50))
    return CFrame.new(target.Position + p, target.Position) * CFrame.Angles(math.rad(90), 0, 0)
end
local function setcam(target)
    workspace.CurrentCamera.CameraSubject = target
end
if ServerHop then
task.spawn(function()
queue_on_teleport(game:HttpGet("https://raw.githubusercontent.com/hotcrossbunnies/dump/refs/heads/main/Junk"))
wait(60)
--// Instant Largest Server Teleporter
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Detect exploit request function
local requestFunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or request
if not requestFunc then
    error("No supported HTTP request function found!")
end

-- Get game name (for debugging/logs)
local gameName = "Unknown"
pcall(function()
    local info = MarketplaceService:GetProductInfo(game.PlaceId)
    gameName = info.Name or gameName
end)

-- Function to fetch a page of servers
local function fetchServers(cursor)
    local url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100", game.PlaceId)
    if cursor then
        url = url .. "&cursor=" .. cursor
    end

    local response = requestFunc({
        Url = url,
        Method = "GET"
    })

    if response and response.Body then
        return HttpService:JSONDecode(response.Body)
    end
end

-- Find largest server with available space
local function findLargestServer()
    local largestServer = nil
    local cursor = nil

    repeat
        local data = fetchServers(cursor)
        if data and data.data then
            for _, server in ipairs(data.data) do
                if server.playing < server.maxPlayers then
                    if not largestServer or server.playing > largestServer.playing then
                        largestServer = server
                    end
                end
            end
            cursor = data.nextPageCursor
        else
            break
        end
    until not cursor

    return largestServer
end

-- Main execution
local server = findLargestServer()
if server then
    print(string.format("Teleporting to largest server (%d/%d players) in %s...", server.playing, server.maxPlayers, gameName))
    TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, LocalPlayer)
else
    warn("No available servers found!")
end
end)
end

workspace.FallenPartsDestroyHeight = tonumber("nan")
game:GetService("CoreGui").RobloxNetworkPauseNotification.Enabled = false
task.wait(.1)
local OldCFrame
local OldPos
do
    local HumanoidRootPart = LocalPlayer.Character.HumanoidRootPart

    OldCFrame = HumanoidRootPart.CFrame
    OldPos = HumanoidRootPart.Position
end
_G.loop = not _G.loop
while _G.loop do

    local Character = LocalPlayer.Character
    local HumanoidRootPart = Character.HumanoidRootPart
    local Humanoid = Character.Humanoid

    for _, Part in ipairs(Character:GetDescendants()) do
        if Part:IsA("BasePart") then
            Part.CanTouch = false
        end
    end

    local PlayerList = Players:GetPlayers()
    table.remove(PlayerList, table.find(PlayerList, LocalPlayer))
    for _, Player in pairs(PlayerList) do
        local VCharacter = Player.Character
        local VHumanoidRootPart
        local VHumanoid
        if VCharacter then
            VHumanoidRootPart = VCharacter:FindFirstChild("HumanoidRootPart")
            VHumanoid = VCharacter:FindFirstChild("Humanoid")
        end
        if VHumanoidRootPart and (OldPos - VHumanoidRootPart.Position).Magnitude < 3000 and VHumanoid and not (VHumanoid.SeatPart and VHumanoid.SeatPart.Anchored == true) then
            setcam(VCharacter)
            for i = 1, 5 do
                HumanoidRootPart.CFrame = VHumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(90), 0)
                HumanoidRootPart.Velocity = Vector3.new(0, -1e9, 0)
                task.wait()
            end
            for i = 1, 5 do
                HumanoidRootPart.CFrame = predict(VHumanoidRootPart)
                HumanoidRootPart.Velocity = Vector3.new(0, -1e9, 0)
                task.wait()
            end

            local V3 = Vector3.new(0, 0, 0)
            Humanoid.Sit = true
            HumanoidRootPart.CFrame = OldCFrame
            for _, v in ipairs(Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.Velocity, v.RotVelocity = V3, V3
                end
            end
            Humanoid.Sit = false
        end
    end
    task.wait()
    setcam(Character)
end
